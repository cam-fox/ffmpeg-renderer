import base64import uuidimport osfrom fastapi import FastAPI, HTTPException, Requestfrom pydantic import BaseModelimport subprocessapp = FastAPI()class RenderRequest(BaseModel):imageBase64: straudioBase64: strdef write_file_from_b64(b64: str, path: str):with open(path, "wb") as f:f.write(base64.b64decode(b64))@app.post("/render")async def render(req: RenderRequest):# crear nombres temporales únicosuid = str(uuid.uuid4())img_path = f"/tmp/{uid}_img.png"audio_path = f"/tmp/{uid}_audio.mp3"out_path = f"/tmp/{uid}_out.mp4"    try:        write_file_from_b64(req.imageBase64, img_path)        write_file_from_b64(req.audioBase64, audio_path)    except Exception as e:        raise HTTPException(status_code=400, detail=f"Invalid base64: {e}")    # comando ffmpeg: imagen fija y audio; corta a la duración del audio    cmd = [        "ffmpeg", "-y",        "-loop", "1",        "-i", img_path,        "-i", audio_path,        "-c:v", "libx264",        "-tune", "stillimage",        "-c:a", "aac",        "-b:a", "192k",        "-pix_fmt", "yuv420p",        "-shortest",        out_path    ]    try:        subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=120)    except subprocess.CalledProcessError as e:        raise HTTPException(status_code=500, detail=f"ffmpeg error: {e.stderr.decode('utf-8')}")    except subprocess.TimeoutExpired:        raise HTTPException(status_code=500, detail="ffmpeg timeout")    # leer video y devolver base64    try:        with open(out_path, "rb") as f:            video_b64 = base64.b64encode(f.read()).decode("utf-8")    finally:        # limpiar archivos temporales        for p in [img_path, audio_path, out_path]:            try:                os.remove(p)            except:                pass    return {"videoBase64": video_b64}